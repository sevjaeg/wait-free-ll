\documentclass[a4paper, 12t]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{lmodern}
\usepackage{gensymb}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{nicefrac}
\usepackage{listings}
% TODO nice?
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{verbatim}
\usepackage{graphicx}
\graphicspath{{./figures/}}

\usepackage{geometry}
\geometry{%
	left   = 2.5cm,
	right  = 2.5cm,
	top    = 3cm,
	bottom = 3cm
}

\usepackage[%
	backend     = biber,
	maxbibnames = 99,
	autocite    = footnote,
	style	    = ieee,
	citestyle   = numeric-comp,
	firstinits  = true,
]{biblatex}
\addbibresource{bibliography.bib}

\usepackage[hang]{footmisc}
\renewcommand{\hangfootparindent}{2em} 
\renewcommand{\hangfootparskip}{2em}
\renewcommand{\footnotemargin}{0.00001pt}
\renewcommand{\footnotelayout}{\hspace{2em}}

% last import!
\usepackage{hyperref}

% TODO
\lstset{
    language=Java,
    basicstyle=\ttfamily,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
}

\title{184.726 Advanced Multiprocessor Programming\\
	   Project 10: Wait-Free Linked List}
\author{
  Severin JÃ¤ger, 01613004
}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\pagebreak

\section{Introduction}

The scope of this project was the implementation of the basic version of the wait-free linked list presented in \cite{timnat12}. By exhaustive benchmarking, the advantages, but also the cost, of wait-free lists was examined. As a reference algorithm, the lock-free linked list from \cite{harris01} was implemented as discussed in the lecture.

%\cite{herlihy12}

\section{The Wait-Free List Data Strcuture}

Lock-free data structures can relatively easily be constructed from the atomic CAS instruction, as the CAS only fails if some other thread has made progress. Achieving wait-freedom requires additional synchronisation between the threads. In list implementation here, this is done by excessive helping between the threads.

%TODO rename opDesc in code
Basically, the list maintains an array of all pending list operations. Whenever a thread initiates an contains, add or delete operation, it publishes an \verb|OperationDescriptor| to this array. The key to wait-freedom is that every thread executing some list operation in the following iterates over this array and helps previous operations. The order of the operations in determined by a \verb|phase|.

The wait-free list offers the following operations. It is claimed in \cite{timnat12} that all these operations can be implemented in a wait-free and linearizable manner.
\begin{itemize}
\setlength\itemsep{0em}
\item{\verb|contains|}
\item{\verb|add|}
\item{\verb|remove|}
\end{itemize}

All three operations internally use the \verb|search| method, which satisfies the same progress and correctness conditions.

The authors admit that the the wait-free list performs significantly worse than the lock-free list presented by \cite{harris01}. However, they came up with some optimizations, which limit the extent of helping. Furthermore, the present a fast-past-slow-path algorithm combining the wait-free and the lock-free approach while maintaining wait-freedom. They claim that this algorithm almost reaches the performance of the lock-free data structure. 
% performance claim in paper (mention SPFP)
% worst-case bounds?

\section{Implementation}

% C++

% Memory management not treated

% counters (ABA) and flags: bit stealing

% contains in reference not strictly wait-free, but left unaltered

\section{Benchmarking}

%machine
%compiler version

%TODO create readme to explain compiling and running

% mix of operations
% phases (fill, operation, empty)

% measure list penalty (going back after CAS failure)

\section{Summary and Outlook}

\sloppy
\printbibliography

\end{document}